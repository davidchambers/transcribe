#!/usr/bin/env node

'use strict';

const fs = require ('fs');

const program = require ('commander');
const Future = require ('fluture');
const sanctuary = require ('sanctuary');

const pkg = require ('../package.json');


const {
  Just,
  Nothing,
  Pair,
  alt,
  append,
  array,
  chain,
  compose: B,
  flip,
  fromMaybe,
  join,
  joinWith,
  lines,
  map,
  pair,
  pipe,
  promap,
  reduce,
  snd,
  splitOn,
  stripPrefix,
  traverse,
  unfoldr,
  unlines,
} = sanctuary.unchecked;

const map2 = B (map) (map);
const map3 = B (map) (map2);
const map4 = B (map) (map3);

//    readFile :: String -> Future Error String
const readFile = path => (
  Future.node (callback => fs.readFile (path, 'utf8', callback))
);

//    writeFile :: String -> String -> Future Error Undefined
const writeFile = path => data => (
  Future.node (callback => fs.writeFile (path, data, callback))
);

//    writeStdOut :: String -> Future Error Undefined
const writeStdOut = data => (
  Future.node (callback => process.stdout.write (data, 'utf8', callback))
);

//    replace :: (String | RegExp) -> String -> String -> String
const replace = patt => repl => s => s.replace (patt, repl);

//    esc :: String -> String
const esc = pipe ([
  replace (/&/g) ('&amp;'),
  replace (/</g) ('&lt;'),
  replace (/"/g) ('&quot;'),
]);

//    nbsp :: String -> String
const nbsp = replace (/[ ]/g) ('\u00A0');

//    controlWrapping :: String -> String
const controlWrapping = pipe ([
  splitOn (' :: '),
  map (splitOn (' => ')),
  map2 (s => join (unfoldr (array (Nothing)
                                  (p => array (Just (Pair ([p, '']) ([])))
                                              (q => B (Just)
                                                      (Pair ([p, nbsp (q)])))))
                           (s.split (/([(][^()]+[)])/)))),
  map3 (splitOn (' -> ')),
  map4 (nbsp),
  map3 (joinWith (' -> ')),
  map2 (joinWith ('')),
  map (joinWith (' => ')),
  joinWith (' :: '),
]);

//    formatSignature :: Options -> String -> Number -> String -> String
const formatSignature = options => filename => num => signature =>
  '#'.repeat (options.headingLevel) + ' ' +
  '<a name="' + esc (replace (/ :: [\s\S]*/) ('') (signature)) + '"' +
    ' href="' + esc (B (replace ('{line}') (num))
                       (replace ('{filename}') (filename))
                       (options.url)) + '">' +
    '`' + controlWrapping (signature) + '`' +
  '</a>';

//    parseLine :: Options -> String -> Number -> String -> String
const parseLine = options => filename => num => pipe ([
  replace (/^\s+/) (''),
  s => alt (map (replace (/^[ ]/) (''))
                (stripPrefix (options.prefix) (s)))
           (map (B (formatSignature (options) (filename) (num))
                   (replace (/^[ ]/) ('')))
                (stripPrefix (options.headingPrefix) (s))),
  fromMaybe (''),
]);

//    parseFile :: Options -> String -> Future Error String
const parseFile = options => filename => (
  map (promap (lines)
              (unlines)
              (B (snd)
                 (reduce (flip (line =>
                                  pair (num => B (Pair (num + 1))
                                                 (append (parseLine (options)
                                                                    (filename)
                                                                    (num)
                                                                    (line))))))
                         (Pair (1) ([])))))
      (readFile (filename))
);

//    transcribe :: Options -> Array String -> Future Error String
const transcribe = options => (
  B (map (pipe ([joinWith ('\n\n'),
                 replace (/\n{3,}/g) ('\n\n'),
                 replace (/^\n+/) (''),
                 replace (/\n+$/) ('\n')])))
    (traverse (Future) (parseFile (options)))
);

program
.version (pkg.version)
.usage ('[options] <file ...>')
.description (pkg.description)
.option ('--heading-level <num>', 'heading level in range [1, 6] (default: 3)')
.option ('--heading-prefix <str>', 'prefix for heading lines (default: "//#")')
.option ('--insert-into <str>',
         'name of a file into which Transcribe will insert generated output')
.option ('--prefix <str>', 'prefix for non-heading lines (default: "//.")')
.option ('--url <str>', 'source URL with {filename} and {line} placeholders')
.parse (process.argv);

let valid = true;

if (!(program.headingLevel == null || /^[1-6]$/.test (program.headingLevel))) {
  process.stderr.write ('Invalid --heading-level\n');
  valid = false;
}

if (program.url == null) {
  process.stderr.write ('No --url template specified\n');
  valid = false;
}

if (!valid) {
  process.exit (1);
}

//    defaultTo :: a -> a? -> a
const defaultTo = x => y => y == null ? x : y;

//    options :: Options
const options = {
  headingLevel: Number (defaultTo ('3') (program.headingLevel)),
  headingPrefix: defaultTo ('//#') (program.headingPrefix),
  prefix: defaultTo ('//.') (program.prefix),
  url: program.url,
};

//    delimiters :: RegExp
const delimiters = /(<!--transcribe-->)[\s\S]*?(<!--[/]transcribe-->)/;

Future.fork
  (e => { console.error (String (e)); process.exit (1); })
  (_ => {                             process.exit (0); })
  (chain (output =>
            program.insertInto == null ?
            writeStdOut (output) :
            chain (writeFile (program.insertInto))
                  (map (replace (delimiters) ('$1\n\n' + output + '\n$2'))
                       (readFile (program.insertInto))))
         (transcribe (options) (program.args)));
