#!/usr/bin/env node

'use strict';

const fs = require ('fs');
const path = require ('path');

const {create, env} = require ('sanctuary');

const pkg = require ('../package.json');


const {
  I,
  Just,
  K,
  Left,
  Nothing,
  Pair,
  Right,
  T,
  alt,
  append,
  array,
  compose: B,
  either,
  equals,
  flip,
  fromMaybe,
  ifElse,
  join,
  joinWith,
  lines,
  map,
  maybe,
  pair,
  pipe,
  prepend,
  reduce,
  regex,
  regexEscape,
  show,
  snd,
  splitOn,
  stripPrefix,
  test,
  unchecked: _,
  unfoldr,
  unlines,
  value,
} = create ({checkTypes: false, env});

const map2 = B (map) (map);
const map3 = B (map) (map2);
const map4 = B (map) (map3);

//    replace :: (String | RegExp) -> String -> String -> String
const replace = patt => repl => s => s.replace (patt, repl);

//    esc :: String -> String
const esc = pipe ([
  replace (/&/g) ('&amp;'),
  replace (/</g) ('&lt;'),
  replace (/"/g) ('&quot;'),
]);

//    nbsp :: String -> String
const nbsp = replace (/[ ]/g) ('\u00A0');

//    controlWrapping :: String -> String
const controlWrapping = pipe ([
  splitOn (' :: '),
  map (splitOn (' => ')),
  map2 (s => join (unfoldr (array (Nothing)
                                  (p => array (Just (Pair ([p, '']) ([])))
                                              (q => B (Just)
                                                      (Pair ([p, nbsp (q)])))))
                           (s.split (/([(][^()]+[)])/)))),
  map3 (splitOn (' -> ')),
  map4 (nbsp),
  map3 (joinWith (' -> ')),
  map2 (joinWith ('')),
  map (joinWith (' => ')),
  joinWith (' :: '),
  replace (/->/g) ('-\u2060>'),
]);

//    formatSignature :: Integer -> String -> String -> Number -> String -> String
const formatSignature = level => url => filename => num => signature =>
  '#'.repeat (level) + ' ' +
  '<a name="' + esc (replace (/ :: [\s\S]*/) ('') (signature)) + '"' +
    ' href="' + esc (B (replace ('{line}') (num))
                       (replace ('{filename}') (filename))
                       (url)) + '">' +
    '`' + controlWrapping (signature) + '`' +
  '</a>';

//    parseLine :: Integer -> String -> String -> String -> String -> Number -> String -> String
const parseLine = level => headingPrefix => prefix => url => filename => num =>
  pipe ([replace (/^\s+/) (''),
         s => alt (map (replace (/^[ ]/) (''))
                       (stripPrefix (prefix) (s)))
                  (map (B (formatSignature (level) (url) (filename) (num))
                          (replace (/^[ ]/) ('')))
                       (stripPrefix (headingPrefix) (s))),
         fromMaybe ('')]);

//    parseFile :: (String -> Number -> String -> String) -> String -> String
const parseFile = parseLine => filename =>
  unlines (snd (reduce (flip (line =>
                                pair (num => B (Pair (num + 1))
                                               (append (parseLine (filename)
                                                                  (num)
                                                                  (line))))))
                       (Pair (1) ([]))
                       (lines (fs.readFileSync (filename, 'utf8')))));

//    defaultOptions :: Options
const defaultOptions = {
  help: false,
  version: false,
  headingLevel: 3,
  headingPrefix: '//#',
  insertInto: Nothing,
  prefix: '//.',
  url: Nothing,
};

//    updaters :: StrMap (Either (Options -> Options) (String -> Either String (Options -> Options)))
const updaters = {
  '-h':
    Left (_.insert ('help') (true)),
  '--help':
    Left (_.insert ('help') (true)),
  '-V':
    Left (_.insert ('version') (true)),
  '--version':
    Left (_.insert ('version') (true)),
  '--heading-level':
    Right (s => maybe (Left ('--heading-level must be in range [1, 6]'))
                      (B (Right) (_.insert ('headingLevel')))
                      (value (s) ({1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6}))),
  '--heading-prefix':
    Right (s => Right (_.insert ('headingPrefix') (s))),
  '--insert-into':
    Right (s => Right (_.insert ('insertInto') (Just (s)))),
  '--prefix':
    Right (s => Right (_.insert ('prefix') (s))),
  '--url':
    Right (s => Right (_.insert ('url') (Just (s)))),
};

//    parseArgs :: Options -> Array String -> Either String (Pair Options (Array String))
const parseArgs = function parseArgs(opts) {
  return array (Right (Pair (opts) ([])))
               (s => test (/^-[a-z]$|^--(?!$)/i) (s) ?
                     maybe (K (Left (s + ' is unrecognized')))
                           (either (B (parseArgs) (T (opts)))
                                   (B (array (Left (s + ' requires a value')))
                                      (B (either (B (K) (Left))
                                                 (B (parseArgs) (T (opts)))))))
                           (value (s) (updaters)) :
                     B (Right)
                       (B (Pair (opts))
                          (ifElse (equals ('--')) (K (I)) (prepend) (s))));
};

/* eslint-disable max-len */

//    help :: String
const help = `
  Usage: ${path.basename (__filename)} [options] <file ...>

  ${pkg.description}

  Options:

    -h, --help              output usage information
    -V, --version           output the version number
    --heading-level <num>   heading level in range [1, 6] (default: ${show (defaultOptions.headingLevel)})
    --heading-prefix <str>  prefix for heading lines (default: ${show (defaultOptions.headingPrefix)})
    --insert-into <str>     name of a file into which Transcribe will insert generated output
    --prefix <str>          prefix for non-heading lines (default: ${show (defaultOptions.prefix)})
    --url <str>             source URL with {filename} and {line} placeholders

`;

/* eslint-enable max-len */

//    abort :: String -> () -> Undefined
const abort = s => () => { process.stderr.write (s); process.exit (1); };

//    print :: String -> () -> Undefined
const print = s => () => { process.stdout.write (s); };

//    insertInto :: String -> String -> () -> Undefined
const insertInto = filename => s => () => {
  const opening = '<!--transcribe-->';
  const closing = '<!--/transcribe-->';
  fs.writeFileSync (filename,
                    replace (regex ('')
                                   (regexEscape (opening) +
                                    '[\\s\\S]*?' +
                                    regexEscape (closing)))
                            (opening + '\n\n' + s + '\n' + closing)
                            (fs.readFileSync (filename, 'utf8')));
};

//    main :: () -> Undefined
const main =
either (s => abort (s + '\n'))
       (pair (opts =>
                opts.help ?
                  K (print (help)) :
                opts.version ?
                  K (print (pkg.version + '\n')) :
                // else
                  maybe (K (abort ('--url is required\n')))
                        (B (B (B (maybe (print) (insertInto) (opts.insertInto))
                                 (B (replace (/\n+$/) ('\n'))
                                    (B (replace (/^\n+/) (''))
                                       (B (replace (/\n{3,}/g) ('\n\n'))
                                          (joinWith ('\n\n')))))))
                           (B (map)
                              (B (parseFile)
                                 (parseLine (opts.headingLevel)
                                            (opts.headingPrefix)
                                            (opts.prefix)))))
                        (opts.url)))
       (parseArgs (defaultOptions) (process.argv.slice (2)));

main ();
